#! /bin/env python
#! /usr/bin/env python2.7
import time
starttime = time.time()
import sys
import argparse
import multiprocessing
import re
from math import sqrt
import os
import random
from tnt.lib import *

MASTER = os.getppid()

def main():
#--------------------------MAIN PROGRAM-----------------------------

#	commandline argument parsing
	argparser = argparse.ArgumentParser(	description='Analysis of Tnt data from the miseq.',
											formatter_class=argparse.RawTextHelpFormatter,
										)
	argparser.add_argument(	'--debug',		dest='debug', 			action='store_true', 			required=False,	default=False,	help='debug (run as regular single process python script).')
	argparser.add_argument(	'--selftest',		dest='selftest', 		action='store_true', 			required=False,	default=False,	help='Run a selftest to see that reads are correctly classified.')
	argparser.add_argument(	'-skip',		dest='skip',	metavar='N',				type=int,	required=False,	default=0,	help='skip the first N read pairs in files (default 0).')
	argparser.add_argument(	'-stop',		dest='stop',	metavar='N',				type=int,	required=False,	default=0,	help='stop after N read pairs, set to 0 to disable (default 0).')
	argparser.add_argument(	'-r1',			dest='reads1',	metavar='FILE',				type=file,	required=True, 			help='indata "fastq"-file read1.')
	argparser.add_argument(	'-r2',			dest='reads2',	metavar='FILE',				type=file,	required=True,	default=None,	help='indata "fastq"-file read2.')
	argparser.add_argument(	'-p',			dest='cpus',	metavar='N',				type=int,	required=False,	default=1,	help='The number of processes to start (default 1).')
	argparser.add_argument(	'-o',			dest='outfile',	metavar='outfile',			type=str,	required=False,	default=False,	help='Print output to outfile (default stdout).')
	argparser.add_argument(	'-l',			dest='logfile',	metavar='outfile',			type=str,	required=False,	default=False,	help='Print log messages to logfile (default stderr).')
	argparser.add_argument(	'-sample',		dest='sample',	metavar='str',				type=str,	required=False,	default=False,	help='Sample name to use for out and logfile namin (default Disabled).')
	argparser.add_argument(	'-random',		dest='n',	metavar='N',				type=int,	required=False,	default=0,	help='Use a random subset of N read pairs, this option is slower (default 0 = off). Can not be used in combination with "-skip" or "-stop"')
	argparser.add_argument(	'--keeporder',		dest='keeporder', 		action='store_true', 			required=False, default=False,	help='keep the read ordering.')
	argparser.add_argument(	'-hm',			dest='handlemm',	metavar='N',				type=int,	required=False,	default=0,	help='Missmatches allowed in handle sequences (default 0).')
	argparser.add_argument(	'-pe',			dest='primeredit',	metavar='N',				type=int,	required=False,	default=0,	help='Editdistance allowed while identifying specific primer sequences (default 0).')
	argparser.add_argument(	'--onlydumpthreads',		dest='onlydumpthreads', 		action='store_true', 			required=False, default=False,	help='only dump the threads do not identify specifics.')	
	indata = argparser.parse_args(sys.argv[1:])
	if indata.outfile: indata.outfile = open(indata.outfile, 'w')
	else: indata.outfile = sys.stdout
	if indata.logfile: indata.logfile = open(indata.outfile, 'w',1)
	else: indata.logfile = sys.stderr
	if indata.sample:
		indata.outfile = open(indata.sample+'.out.txt', 'w')
		indata.logfile = open(indata.sample+'.log.txt', 'w')
		try: os.mkdir(indata.sample+'.threads')
		except OSError:pass
	indata.logfile.write('Start.\n')
	
	indata.logfile.write('Running script '+time.strftime("%A, %d %b %Y %H:%M:%S",time.localtime())+'.\n')
	indata.logfile.write('Master process id='+str(MASTER)+'\n')
	indata.logfile.write('cmd: '+' '.join(sys.argv)+'\n')
	if indata.selftest: indata.logfile.write('Running in selftest mode no real data will be analyzed.\n')
	
	indata.logfile.write('Getting readcount ... ')
	numreads=bufcount(indata.reads1.name)/4
	indata.reads2process = numreads
	if indata.skip: indata.reads2process -= indata.skip
	if indata.stop: indata.reads2process = indata.stop
	if indata.n:    indata.reads2process = indata.n
	indata.logfile.write('#read pairs in indata file:\n'+str(numreads)+'\n')
	indata.logfile.write(str(numreads)+' read pairs in fastq files.\n');
	
	#deciding if to run multiprocessing or single process for debbuging
	if indata.debug:
		results=[]
		indata.logfile.write('Part1: Running in debug mode searching for threads ...\n')
		progress = Progress(indata.reads2process)
		with progress:
			for tmp in getPairs(indata):
				progress.update()
				results.append(magicFunction(tmp))
		indata.logfile.write('Part1: search finished\n')
	else:
		#create worker pool
		WorkerPool = multiprocessing.Pool(indata.cpus,maxtasksperchild=100)
		if not indata.keeporder: results = WorkerPool.imap_unordered(magicFunction,getPairs(indata),chunksize=10)
		if indata.keeporder:     results = WorkerPool.imap(magicFunction,getPairs(indata),chunksize=10)

	if not indata.debug: indata.logfile.write('Part1: running in multiproccessing mode using '+str(indata.cpus)+' processes  ...\n')
	else: indata.logfile.write('Part2: running the multiprocessing results handeling in serial\n')
	
	counter = 0
	last = [0,starttime,counter]
	combos = {}
	threadsbycombo={}
	threads=0
	identifiable=0
	bothidentifiable=0
	same = 0
	notsame = 0
	progress1 = Progress(indata.reads2process)
	with progress1:
		for pair in results: # do this for each result
			counter += 1
			progress1.update()
			for thread in pair.threads:
				threads+=1
				try:		combos[str(thread.extprimer)+'-'+str(thread.tjprimer)]+=1
				except KeyError:combos[str(thread.extprimer)+'-'+str(thread.tjprimer)]=1
				if indata.sample:
					f = open(indata.sample+'.threads/'+str(thread.extprimer)+'-'+str(thread.tjprimer)+'.txt','a')
					f.write(thread.seq+'\n')
					f.close
				if thread.tjprimer or thread.extprimer:
					identifiable+=1
					if thread.tjprimer and thread.extprimer:
						bothidentifiable+=1
					if thread.tjprimer == thread.extprimer:
						same+=1
						pass#print thread.extprimer, thread.seq
						try:threadsbycombo[thread.extprimer].append(thread)
						except KeyError:threadsbycombo[thread.extprimer]=[thread]
					elif thread.tjprimer and thread.extprimer: notsame += 1
	
	for combo,count in combos.iteritems():
		indata.outfile.write( str(count)+ '\t'+str(round(100*float(count)/(threads),2))+'\t'+ combo+'\n')
	indata.logfile.write('Part 1 finished in '+str(round(time.time()-starttime,2))+'s, '+str(counter)+' reads processed,\n '+str(threads)+' ('+str(int(round(100*float(threads)/(counter*2))))+'%) threads,\n whereof '+str(identifiable)+' ('+str(int(round(100*float(identifiable)/threads)))+'%) were identifiable \nwhereof '+str(bothidentifiable)+' ('+str(int(round(100*float(bothidentifiable)/identifiable)))+'%) were both primers identifiable \nwhereof '+str(same)+' ('+str(int(round(100*float(same)/bothidentifiable)))+'%) were both primers are the same (vs '+str(notsame)+' ('+str(int(round(100*float(notsame)/bothidentifiable)))+'%) unspecific products).\n')	
#--------------------------MAIN PROGRAM END-------------------------


#--------------------- Functions, Subroutines and classes --------------------
def comp(str):
	return str.replace("A","X").replace("T","A").replace("X","T").replace("G","X").replace("C","G").replace("X","C")

def revcomp(str):
	return comp(str[::-1])

def bufcount(filename):
	""" returns the number of lines in a file
	"""
	import gzip
	if filename.split('.')[-1] in ['gz','gzip']: f = gzip.open(filename)
	else: f = open(filename)
	lines = 0
	buf_size = 1024 * 1024
	read_f = f.read # loop optimization
	
	buf = read_f(buf_size)
	while buf:
		lines += buf.count('\n')
		buf = read_f(buf_size)
		f.close
	return lines

def getPairs(indata):
	""" yield one readpair at a time from indata
	"""
	if indata.selftest:
		pass #no selftest excist at this point
		return

	[file1,file2]=[indata.reads1,indata.reads2]
	import gzip
	if file1.name.split('.')[-1] in ['gz','gzip']: file1 = gzip.open(file1.name)
	if file2.name.split('.')[-1] in ['gz','gzip']: file2 = gzip.open(file2.name)

	if indata.n:
		numreads=bufcount(indata.reads1.name)/4
		if indata.stop: numreads = indata.stop
		indata.logfile.write('Choosing '+str(indata.n)+' random pairs to analyze ... ')
		readNumbersToPrint = {}
		while len(readNumbersToPrint) < indata.n: readNumbersToPrint[random.randint(indata.skip+1,numreads)] = True
		tempo = readNumbersToPrint.keys()
		tempo.sort()
		readNumbersToPrint = tempo 
		indata.logfile.write('done.\n')
	counter = 0
	tmp=0
	header="NA"
	if indata.skip: skip =True

	for r1line in file1:
		r2line = file2.readline()
		tmp+=1
		if indata.skip and tmp < (4*indata.skip) and skip: continue
		elif indata.skip and tmp == (4*indata.skip) and skip: skip=False; tmp =0;continue
		if indata.stop and counter == indata.stop: break
	
		if tmp == 1: #header
			header=r1line
			if r1line.split(" ")[0] != r2line.split(" ")[0]: indata.logfile.write('Error mismatching headers!');os.kill(MASTER,1);sys.exit(1);#REALLYNOTOPTIMAL
		elif tmp == 2: #sequence
			if counter == 1:
				indata.logfile.write('Checking data type of read 1 in pair 1 ... ')
				match = re.match("^[AGTCN]+$",r1line.rstrip())
				if match: indata.logfile.write('this is DNA data.\n')
				else: indata.logfile.write(' this is not a DNA sequence ('+r1line.rstrip()+') could something be wrong with your indata file?.\n\n');os.kill(MASTER);sys.exit();#REALLYNOTOPTIMAL
			r1seq = r1line.rstrip()
			r2seq = r2line.rstrip()
		elif tmp == 3: #+
				if counter in {1:True,67:True,438:True,9675:True,53678:True,864513:True,1337354:True,317955:True,1226844:True,20389:True,118261:True}:
					if r1line[0] != r2line[0] or r1line[0] != '+': indata.logfile.write('Error Format not fastq!');os.kill(MASTER);sys.exit(1);#REALLYNOTOPTIMAL
		elif tmp == 4: #quality
				tmp=0
				counter+=1
				r1qual = r1line.rstrip()
				r2qual = r2line.rstrip()
				if not indata.n: yield [readpair(header.rstrip(), r1seq, r2seq),indata]
				else:
					if counter == readNumbersToPrint[0]:
						yield [readpair(header.rstrip(), r1seq, r2seq),indata]
						readNumbersToPrint = readNumbersToPrint[1:]
						if len(readNumbersToPrint) == 0: break

class readpair():
    """ object representing an illumina cluster """
    
    def __init__(self,header,r1,r2):
		self.header = header
		self.r1 = read(r1,1,header) #first read
		self.r2 = read(r2,2,header) #second read
		self.threads = []

    def identifythreads(self,indata):
		# a thread should look like this:
		# gagctgctgcaccatattcctgaac GACCATCACTTAAATCAGGTCCTCC NNNNNNNNNNN AGAGTCAAGTTATTTAAAAAATCTGGCC gctctgaaggcggtgtatgacatgg
		# GAGCTGCTGCACCATATTCCTGAAC CAATCTCCCCTATTATTTCTATCCTATGCCACTCCTGCTCATATCTCTAGTG GCTCTGAAGGCGGTGTATGACATGGAGATCGGAAGAGCACACGTCTGAACTCCAGTCACATTCCTTTATCTCGT
		# gagctgctgcaccatattcctgaac                                                      gctctgaaggcggtgtatgacatgg
		
		exthandle_seq = 'gagctgctgcaccatattcctgaac'.upper()
		tjhandle_seq  = 'gctctgaaggcggtgtatgacatgg'.upper()
		
		matchfunk = hamming_distance
	
		#READ1
		exthandle = None
		tjhandle =  None
		exthandle = re.search('^'+exthandle_seq,self.r1.seq)
		tjhandle =  re.search(tjhandle_seq,self.r1.seq)
		if exthandle and tjhandle:
			thread = tntthread(self.r1.seq[exthandle.end():tjhandle.start()])
			self.threads.append(thread)
		elif indata.handlemm: # do some kind of fuzzy matching to allow for missmatches
			if not exthandle: 
				mindist = [10000,-1]
				for i in range(len(self.r1.seq)):
					if i+len(exthandle_seq) <= len(self.r1.seq): dist = matchfunk(exthandle_seq,self.r1.seq[i:i+len(exthandle_seq)])
					else: dist = 1000
					if dist < mindist[0]: mindist =[dist,i]
				if mindist[0] < indata.handlemm: exthandle_end = i+len(exthandle_seq)
				else: exthandle_end = None
			else: exthandle_end = exthandle.end()
			if not tjhandle: 
				mindist = [10000,-1]
				for i in range(len(self.r1.seq)):
					if i+len(tjhandle_seq) <= len(self.r1.seq): dist = matchfunk(tjhandle_seq,self.r1.seq[i:i+len(tjhandle_seq)])
					else: dist = 1000
					if dist < mindist[0]: mindist =[dist,i]
				if mindist[0] < indata.handlemm: tjhandle_start = i
				else: tjhandle_start = None
			else: tjhandle_start = tjhandle.start()
			if tjhandle_start and exthandle_end:
				thread = tntthread(self.r1.seq[exthandle_end:tjhandle_start])
				self.threads.append(thread)
		
		#READ2
		exthandle = None
		tjhandle =  None
		exthandle = re.search(   revcomp(exthandle_seq),self.r2.seq)
		tjhandle =  re.search('^'+revcomp(tjhandle_seq),self.r2.seq)
		if exthandle and tjhandle:
			thread = tntthread(revcomp(self.r2.seq[tjhandle.end():exthandle.start()]))
			self.threads.append(thread)
		elif indata.handlemm: #### do some kind of fuzzy matching to allow for missmatches
			if not exthandle: 
				mindist = [10000,-1]
				for i in range(len(self.r2.seq)):
					if i+len(exthandle_seq) <= len(self.r2.seq): dist = matchfunk(exthandle_seq,revcomp(self.r2.seq)[i:i+len(exthandle_seq)])
					else: dist = 1000
					if dist < mindist[0]: mindist =[dist,i]
				if mindist[0] < indata.handlemm: exthandle_end = i+len(exthandle_seq)
				else: exthandle_end = None
			else: exthandle_end = exthandle.end()
			if not tjhandle: 
				mindist = [10000,-1]
				for i in range(len(self.r2.seq)):
					if i+len(tjhandle_seq) <= len(self.r2.seq): dist = matchfunk(tjhandle_seq,revcomp(self.r2.seq)[i:i+len(tjhandle_seq)])
					else: dist = 1000
					if dist < mindist[0]: mindist =[dist,i]
				if mindist[0] < indata.handlemm: tjhandle_start = i
				else: tjhandle_start = None
			else: tjhandle_start = tjhandle.start()
			if tjhandle_start and exthandle_end:
				thread = tntthread(revcomp(self.r2.seq)[exthandle_end:tjhandle_start])
				self.threads.append(thread)

def hamming_distance(s1, s2):
    assert len(s1) == len(s2), 'Error: '+str(len(s1)) + ' != ' + str(len(s2))
    return sum(ch1 != ch2 for ch1, ch2 in zip(s1, s2))

class read():
    "Represents one of several reads from a DNA fragment"
    
    def __init__(self,seq,number,header):
	self.seq = seq
	self.number = number
	self.handlesearch = 'NotStarted'
        self.header = header
	return

class tntthread():
    "Represents the specific part of a tnt thread without the general handles"
    
    def __init__(self,seq):
	self.seq = seq
	self.extprimer = None
	self.tjprimer = None
	return

    def identifyspecific(self,indata):
	try:
		for ID in extbyseq[self.seq[:19]]:
			match = re.search('^'+ext_primers[ID], self.seq)
			if match:
				self.extprimer= ID;
	except KeyError: pass
	try:
		for ID in tjbyseq[self.seq[-19:]]:
			match = re.search(tj_primers[ID]+'$', self.seq)
			if match:
				self.tjprimer= ID;
	except KeyError: pass
	
	matchfunk = levenshtein
	
	if not self.tjprimer and indata.primeredit:
		minedit = [300, 'NA']
		for primer_id, seq in tj_primers.iteritems():
			dist = matchfunk(seq,self.seq[-len(seq)::])
			if dist < minedit[0]: minedit = [dist, primer_id]
			if minedit[0] <= indata.primeredit: break
		if minedit[0] <= indata.primeredit: self.tjprimer = primer_id
	if not self.extprimer and indata.primeredit:
		minedit = [300, 'NA']
		for primer_id, seq in ext_primers.iteritems():
			dist = matchfunk(seq,self.seq[:len(seq)])
			if dist < minedit[0]: minedit = [dist, primer_id]
			if minedit[0] <= indata.primeredit: break
		if minedit[0] <= indata.primeredit: self.extprimer = primer_id
	
	#if not self.extprimer:
	#	mm=3
	#	vote=[]
	#	for i in range(19):
	#		#print i, self.seq[i], extprimerpositions[i][self.seq[i]]
	#		for ID in extprimerpositions[i][self.seq[i]]:
	#			vote.append(ID)
	#	if vote.count(max(vote)) > 19-mm: print 'update ext:',max(vote)
			

def magicFunction(tmp):
	#unpack input and trim reads
	[pair, indata] = tmp
	
	pair.identifythreads(indata)

	for thread in pair.threads:
		thread.identifyspecific(indata)
	
	return pair

def levenshtein(s1, s2):
    """
    calculates the levenshtein distance between two sequences, modified to not count N as missmatch
    """
    if len(s1) < len(s2):
        return levenshtein(s2, s1)
    if not s1:
        return len(s2)
 
    previous_row = xrange(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1 # j+1 instead of j since previous_row and current_row are one character longer
            deletions = current_row[j] + 1       # than s2
            substitutions = previous_row[j] + (c1 != c2)
	    if c1 == 'N' or c2 == 'N': substitutions -= 1 #if N then no mismatch
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
 
    return previous_row[-1]

ext_primers = {
	'c1':'GACCATCACTTAAATCAGGTCCTCC',
	'c2':'CTCTTCAGCTCCCAGAGTCACCA',
	'c3':'TGGATTTTTACATATGAGCCTTCAATG',
	'c4':'GGCCAACAAGATCAGTCTGTTCTCT',
	'c5':'ACCCTAGATTGTATTGTAGGAGGCAT',
	'c6':'CTTTCATTCTGCTCAAGTCTTCGCC',
	'c7':'CCGGCCTCTGGCGTTCTACTCA',
	'c8':'TTGCACAAGGTAAGTTTATTCTAGCTT',
	'c9':'CCTGAATATCAGGTAGGAATGTTTGT',
	'c10':'ACAAAGGCAGCCTTTCATACCTTAG',
	'c11':'CAAACCTTACAGCATCGATAAGTTTC',
	'c12':'GCGGTGGGCGCGCAGTGCGTTCTC',
	'c13':'CCAGGGTAAGGGAGAGGGCCACA',
	'c14':'ATATGTTCCCTTCCTGAATTTGTCTAA',
	'c15':'AAAAGCCTAAGAACTCTAAGCATTGC',
	'c16':'GAACACTGCCCTCGCACGGCCCC',
	'c17':'CAGCTAGAGATAGGGGAAGTGTATA',
	'c18':'CTTCCACTCTCAAAGGGCTTCTGAT',
	'c19':'TGGATTCTGAATGTGCTTAATTTAAAAG',
	'c20':'CTAATTCTGTTTCATTTCTATAGGCGA',
	'c21':'CTTCCCTCTCCTCAGCGCCTAAGAG',
	'c22':'GTGAGAATCCCTGAGCCCAGGCGGT',
	'c23':'GGCACCTTTCCTCTAATCCAGCAAA',
	'c24':'CATTTCAAGGCAGTTTTTAAAGAAGTC',
	'c25':'CTAGGACTCCTGCTAAGCTCTCCT',
	'c26':'GTTTCAAAGCGCCAGTCATTTGCTC',
	'c27':'GGAGCTGCTGGTGCAGGGGCCACG',
	'c28':'GTGCCTGGACATTTGCCTTGCTGGA',
	'c29':'GTGTGAGAGAAAAGAATGGAATAAGC',
	'c30':'TTCCAATGTCCCCCGGTTGGAGTC',
	'c31':'GGTGGAGCCACACGAAGCGGTG',
	'c32':'AGGCAGGGCAGGTCCAGGCCCTGC',
	'c33':'GAGGTATCAGAGGTAATAAATATTCTAT',
	'c34':'CTCCCCCACCCCGCTTCACTCTG',
	'c35':'TCCCCGCCTGGGGAAGGAGAGGCC',
	'c36':'GAATTCATCGGACATGTTACTGTTTTT',
	'c37':'TAAAGTTTGGTCCCTTTCGCTCCG',
	'c38':'GTCAGGATTGCTGGTGTTATATTCTG',
	'c39':'GTTTGATTCACCTTTGAGCACTCTTA',
	'c40':'ATTCCTCTGGTATTTTCTAAAACAGAAA',
	'c41':'CTAGCTGGCCTTATTCTACTGACTT',
	'c42':'GTACTGGACGTTGATGCCACTGAA',
	'c43':'AGAAAGTGAGGACAGACAGAAGGC',
	'c44':'CATCTGCAGTCCCTGGGGGCCA',
	'c45':'GGATGGCGAGGCAGCAGGGGCA',
	'c46':'TGCGTCGGCGGCTGCCCTCCC',
	'c47':'GATTCTCACGACTCTACCATGTCCA',
	'c48':'GGAGGGCTGGGAGTCCGGAATG',
	'c49':'CCAGTCCTGTCATGTCAGGGTTG',
	'c50':'AGCGGATGGTGGATTTCGCTGGC',
	'c51':'TTCCTGGCTCCATTTTCTCCACCAG',
	'c52':'CCTGCCCAGGCTGAGTGCGGA',
	'c53':'GCGAGGATGTCGTCCACCTCTG',
	'c54':'TGATGCTTTCGAAGTTTCAGTTGAAC',
	'c55':'TCGGACCGCATGGGTCGGACAGGT',
	'c56':'GCAAGCGGTGAGTTTTCAGATGGGCA',
	'c57':'TTGATATTCTTCATTAGCTTGCCTGAT',
	'c58':'TGTCTGCTCCAAATATAGCAATGAAG',
	'c59':'CTGGGGGGTGGCTCAGGGGAGGGTG',
	'c60':'GTTCTGGCAGGCATTTGGCATCAGC',
	'c61':'GAGGGCTAAAAAGGTCCTGTAAGAAG',
	'c62':'CCTTCCCGGTCAGCTACTCCTCTTCC',	
	'c63':'GTCGTTTCCAAGAGAGATCCTTTCTT',
	'c64':'TGTTTTCACTGTCTTGCTTCTGGTAA',
	'c65':'GCACAGAAAGACCTGTGTGCTGC',
	'c66':'CAGGCCATACTCTCCTTTACCATACTA',
	'c67':'GCTGGACAGGAAGGGAGAATTCTGA',
	'c68':'GGAGCTGCAGAGGTGTGGGCCCCTG',
	'c69':'ATATTTCAAGAGCTCCCATGTTCAGT',
	'c70':'TTTTAATAATCGACTTTTTAAATGTGATCA',
	'c71':'TAGGTAAAAATTATTAAGTGAAATTATTCAT',
	'c72':'GGCGGGTCTGGGTGCGGCCTGCCGCA',
	'c73':'TTTTAGTTTGGTGATAGAACAGCTCTT',
	'c74':'GGCCAGGACCAGTTGGGCAACAAAAT',
	'c75':'ACCAGAGAGGCTCTGAGAAACCTC',
	'f1':'CATGGTCTGGAGTCTCGGAGTCC',
	'f2':'ACTCATTTTCCTGGTGTTTCAAATATTT',
	'f3':'TTGAGTCGTGGTTTCCTGGTCATG',
	'f4':'TGTCTAGGCCTTAGTTAATAATGAATG',
	'f5':'GCGCCTTCTTGCTGGCACCCAAT',
	'f6':'TGCATCTGAATGGGCAAGAAGGAG',
	'f7':'CCATTGGGAGAGAAGGAAGAGTGG',
	'f8':'AAGGAGAAAGAGAGCCAGGACAAG',
	'f9':'AGAAAGAGCTGGGACCCTGGGAA',
	'f10':'CAACTAATCCAATGTGTGCCTTCACT',
	'f11':'GCGGATGGTGGATTTCGCTGGC',
	'f12':'ACCCCAGGCCTTTTGCCAAACCA',
	'f13':'CAACCTCAGCAGCACCTCCCAC',
	'f14':'CTTTTAGGGATTGGGAAAAGTTTCAAAA',
	'f15':'GAGGTACCGACCCGGACTTCCA',
	'f16':'CACCAGCCAAGCTGCAGCCCC',
	'f17':'CCTGTTTGAGAAGTGGAAGCTCTAC',
	'f18':'AGACTGGGCCCTGCACCTCCC',
	'f19':'GCCACCGCCCAGGGCCCGG',
	'f20':'CTTTTGCTGAGCCCGTTTGTGTTTT',
	'f21':'CGTTATCTTCTCAAACTCTTTGGCC',
	'f22':'GAGATGATCCCTTGCTGACTTACC',
	'f23':'GAGAATAATTAATGGAGATACTATGAAAAA',
	'f24':'AAGTGCTTCTCTAGCAAAAATTCTCC',
	'f25':'AATCACATCTGGTGGAGTAATTTTCC',
	'f26':'CTTATGTGCAGACAACATTGAAGGAA',
	'f27':'GCCAGAACATCCAAGGCCTCCC',
	'f28':'CGTTGTGTGACATCCCGACAGAAA',
	'f29':'AAAGCATGGTACAAAATGAACTATGGT',
	'f30':'CTGACCAGTCTCTGGACATGAAGA',
	'f31':'TGCCAGGGATCAGTGAGGTCTCT',
	'f32':'GCTCCTTTGCCCCCATTAGCCAG',
	'f33':'GTTGCTTTGTTGTTGTCTCTGTATGA',
	'f34':'AAAGGTGTCCTGGGAACAATCACC',
	'f35':'ACACCGCGGTACTGGGCGCTG',
	'f36':'GGTGTTTTCTCTGTTTATGGACAGAG',
	'f37':'AAAAGTTATTGACCCCTAGAAAATGAC',
	'f38':'TGTGGGTGTATTTAACCAATAGCAGT',
	'f39':'TTAGAAGGCAAAGATTATCATGCTGG',
	'f40':'AAGATTTAAAATTAAGCATAGAAATATTGAA',
	'f41':'TACTGTGATTGCTTTCAATCTATAAATC',
	'f42':'CTTTGTAGGCTAGGGCAAGGAATTT',
	'f43':'CACTGAGCTTTAACACCAATAAGTGC',
	'f44':'CTAGAGCAATCCGAATAAAACATAATCA',
	'f45':'TTGCTCCTCCACATATATTAATTTTATG',
	'f46':'GCATAAAGTTATATAGAAAAGACCTACA',
	'f47':'GATAGGATGCGTACAGGAATAAATCT',
	'f48':'ACATGTTTTTCTCTATACCTTTTGGTG',
	'f49':'GGTAAATTAAAGAAATGTGAAGAATTTTTA',
	'f50':'CAATCCTGGATCTATGTAATGGATGT',
	'f51':'AATTACCTTATGATAATTTATTATGGCAAT',
	'f52':'AGCACTTTATTCTCTGCAGGAGTATA',
	'f53':'TAGTTTTGAGTATTGTAGATACCTTATG',
	'f54':'CATTTACTTGCTTGTCCCCTTCCAG',
	'f55':'ATACTCTTCCAATTGTTTTCTATCTTTTA',
	'f56':'GGATGCTTTAAGGAAGCATCTTGCC',
	'f57':'GAGGCTTGGCAGTCACCTGGGT',
	'f58':'TTAACTGTGGTCATAGTCACTCTCAA',
	'f59':'TGCTGTATCAACATTTCAGCAGCTC',
	'f60':'GTTCCTGACCTCTGAATGAGAGGG',
	'f61':'CCAGTGGGTGGGAGAGAAAGGAC',
	'f62':'TTCTTACGGAGTTGTCTTAATAAAGAC',
	'f63':'CCCACCTTGGGTGGTGTAATACAC',
	'f64':'GGTCTTCGGGAACCCTAAAATCAC',
	'f65':'GGTTTTAAATCCCTTACAAACATTAGATT',
	'f66':'TATTTTTTAAACATCTCAAGTGCTGTCA',
	'f67':'AATCATATCGTCTGGCTAAAAGTTGTA',
	'f68':'CATGATCAGAAACTACCAAATCATGAT',
	'f69':'TTATTGCTTGAGAAATAAATAATATAAATAAA',
	'f70':'CAATCTCCCCTATTATTTCTATCCTAT',
	'f71':'AAAAAAATTGCCATCTGGTTTCCAACA',
	'f72':'CCTCTCATGACCCAGGAAGGCC',
	'f73':'CCACAATACTGTAATCACACAGATAC',
	'f74':'CGCAGAGCCTAATCACTACACCC',
	'f75':'GGGAAGTGATTTACAGGCAGGAGTA'
}
tj_primers = {
	'c1':'AGAGTCAAGTTATTTAAAAAATCTGGCC',
	'c2':'CCACTTACATACTTGTCCCTCTAAG',
	'c3':'CCTGGTTACTATTATTAAAGAATTTCTC',
	'c4':'CTGCTTATCTGACAACCCTCAGATC',
	'c5':'ATGGATGGCTGCTGGAAACCCCT',
	'c6':'CCGATCCCTATCTACTTTCTCTCC',
	'c7':'ACCTCTTTGTCCTGCAGCAGTTTTC',
	'c8':'ATTTTGTGGTGAAAGTGCCTAAATTTG',
	'c9':'ATCGCGCTCCCTGAGGATACTCA',
	'c10':'CCAGCTTCCCAGAAGTTGTGCATA',
	'c11':'AAAGAAACCAATGTTTGCAAAGTAGATA',
	'c12':'AGGGCAGCTGTTCCGCCTGCGAT',
	'c13':'CCTTGGAGTTTGAAAGACAAAGGGA',
	'c14':'CTGAGTTGGGGGGTGGTTGCTG',
	'c15':'CGCCAAGTTTGAAGGAACTCGAATT',
	'c16':'CCCCCACATTTGTGCCGACACTGTT',
	'c17':'CCCAATGCTTCCAAAGAGGAAAGG',
	'c18':'ACATTTGAATCTAATGGATCAGTATCAT',
	'c19':'ATTTTTACAAAGTGATCGAAAGTTTTATC',
	'c20':'CATGATCAGGAAGGCCGGGTGAT',
	'c21':'CCCAGTGCGGGTGAGGAGTCGCGA',
	'c22':'CCAGGAGGTGTCTGGACTGGCTGG',
	'c23':'CCCTGCACACCAGAGACAAGCAG',
	'c24':'CAGACGGCGGCACCTTTCCTCT',
	'c25':'ACGCTTTTGCTAAAAACAGCAGAACT',
	'c26':'AAATCCAGGAAATGCAGAAGAGGAAT',
	'c27':'AGCAGCCTCTGGCATTCTGGGAGCT',
	'c28':'ACTGGGGATGTGGGAGGGAGCAGA',
	'c29':'CTGCCATGCTCAGAGAATCCTAGA',
	'c30':'ATCTGCAATGCTCCAGAGGGCAAGA',
	'c31':'AATTAGTGGTCGGATTTCCAAAGACA',
	'c32':'CTGAGTGCCGGGGACGTACAGTGGC',
	'c33':'CAATAAGGTTTCTCAAGGGGCTGG',
	'c34':'ACTGGAGCCCCACAGCCCCCAC',
	'c35':'AGCGGCGGCACGGCCGCCTTCG',
	'c36':'ATGTACCACCAACTTTACGTTTGCAT',
	'c37':'AAAATGCTCTAACGGCAGGAGGTC',
	'c38':'CAAAACAAGGAGAGAAGGAGTTGGA',
	'c39':'CAGAAGAGGCGTAACTGGTTACAAA',
	'c40':'CATCAACTTTGTGTATCTATTCAGAAAA',
	'c41':'AAGGCTGCTCCAGCCAGCACTG',
	'c42':'AGTTTTCCACACAGACTTTCCCGAT',
	'c43':'CACCATGTCACCCTCAGGCGTG',
	'c44':'AGCTGAGCAGTGCCTTCCAGAGC',
	'c45':'AGCTTGGGATGCCCTAGGAAGGG',
	'c46':'CCTCACACGCCAACCCTGCTCCT',
	'c47':'CAGAGATCGTTCCTATACATTTCTGT',
	'c48':'AGTTGTGGGGCCCAGACTCCTAG',
	'c49':'CTCAGGGGAAAATATGAGGGGCAC',
	'c50':'CAAGGTGTGCATGCCTGACCCGT',
	'c51':'AATACATGAGCCAGACCCGCAGCTT',
	'c52':'AGAGCTCCACCGAGGGGTGGG',
	'c53':'ACCTTGGACACCGGGACAAAGGT',
	'c54':'AAAAAGTTTCTTTAAATGTAAGAGCAGG',
	'c55':'ATCTAAGTGGGACAAGTTGACCCAGG',
	'c56':'AGAAGTGCATGTCCAGTGCCTGGC',
	'c57':'CCATAGTAGAAACACATCAGTACTGA',
	'c58':'ACCCTCAACCTCTGCTGTCAAAGT',
	'c59':'CAGGCGGTTCAAGCCGTTGGCTGGA',
	'c60':'ACTCGTCCACATCCTCGGTACAGTA',
	'c61':'ATAGCACCCGTGGTGCATGGTATG',
	'c62':'CCCGCCGGCCCTCGCTGGACTCCA',
	'c63':'ATACACATCTGTACTGGGAGCTTGG',
	'c64':'ACCAGGTGTGGAATTCGAGTTCCT',
	'c65':'ACTCACATTCAGTACATTTGGGTTCC',
	'c66':'ACTGGACTCAGGCTGGAGGCAGA',
	'c67':'AACATGCAGCGAAGTATCATGTGAG',
	'c68':'CCCAGAAGTCCAGCCACTGGGCTCC',
	'c69':'CCTGGAGAAGGAAAGCTCTTTTTGT',
	'c70':'CTATAATATTGTACAGTTATTATAGGGC',
	'c71':'CTTTCAGTTTCATCTTTCTCCTGGG',
	'c72':'CTCGTGGTTCGGAGGCCCACGTGGC',
	'c73':'CATGAGTACGTATCTTTTCTTTTAAAAG',
	'c74':'CTGGGCACTTGCTGCCAGTACTGGG',
	'c75':'AAACTTAGATCATCAGTCACCGAAGGT',
	'f1':'TGGCCACGATGACCAGCAGGTTG',
	'f2':'TTTTAGGTAGTAAAGGCTTTTGTCGTT',
	'f3':'TAATAGCAGTAGAACAGCTCCCAGC',
	'f4':'TTCATATAGTTTATATCAGTGTAGGAGG',
	'f5':'CCATGCGCCGGACCACGACGT',
	'f6':'CCTGACACAATCCACACCATCAGA',
	'f7':'CAGAAAAGACTTCTTGGGCTGGGT',	
	'f8':'CTCTCTCCCTCCCTGAGCTGGA',
	'f9':'TGGCCTCCAGGTAGTCTCAGGAG',
	'f10':'TTCAATTCATTGAGAAAACCTGCCCA',
	'f11':'CAAGGTGTGCATGCCTGACCCG',
	'f12':'TAGAAGGCCACAGAGGAAAGGGG',
	'f13':'CCCGGAGGTGGACCCGGGCT',
	'f14':'CTTCTTGCTGAAAGCGAGTTTTTACT',
	'f15':'CATCCTCTGCCCCTTCTGCTTGA',
	'f16':'TCTAGCAGGCTGGCTCCGCCC',
	'f17':'CCAGTGTCACCACAACCTGAGCC',
	'f18':'TGCTAGCATTTGCAGGCCTACCC',
	'f19':'TCATCGTTGTCCTCGGACACCGG',
	'f20':'CATCCACAGGGTCCAGGCTGCT',
	'f21':'CCATTCTGGAGGAGTTTGTTTTGTTC',
	'f22':'CCCACCAAAGTTCACCCTGAAGG',
	'f23':'TGTCACTTTACTTTGGAAGGTATTCC',
	'f24':'CTTTCTCTAATAGCTCATGGGAGATA',
	'f25':'CACCTCTAATGTCAGTTCAGCCCA',
	'f26':'TTTGTTTCAACAGTAAATTCTTTAGTTTTT',
	'f27':'TGCGATGAGGTGCACATAGCTGG',
	'f28':'TTGTGAAATCGACAATACTGGCATTTG',
	'f29':'CAAGAAGGAGAGGTGGCTAGACC',
	'f30':'TGTTGGAAGTGGGAAGGCTCCCT',
	'f31':'TTGGGGAGCTTGCCCAAGTGGG',
	'f32':'TCCTTCTCACCACCACCTCCGC',
	'f33':'TGTCTAGTGATGGGTGGATCAGTC',
	'f34':'TGTGGTAAAAACAGAAGGGCGGATG',
	'f35':'TGTAGCGCGCACTGGCCCCTG',
	'f36':'TGTGTGTGTAGTATGTGTTTTTTGCAT',
	'f37':'CACATACTTCAATTAAAATGAGTAGTAC',
	'f38':'TTTCCAATCAGTTTGTCTTAAAGATTTG',
	'f39':'CCCAATTATAAACAACCTACAAGAAATC',
	'f40':'CCCCATAATATTAATGGTTTTGTGTTAA',
	'f41':'CGGAAAATTGATGTCTCAACAATACTG',
	'f42':'CTAAGCTCTTAAAAGGTTTCAAGCATG',
	'f43':'CCGTATTCATCCTCATTCTCATTTCT',
	'f44':'CCACTCCTGCTCATATCTCTAGTG',
	'f45':'TCCTTTATTGGTTACATTTGTCATTTCC',
	'f46':'CGGAAGACAAGTACATCAACACGTA',
	'f47':'CCTAATTTTACGTGAGATATTTCTCAG',
	'f48':'TCCTAAAAGCCTAAGTCATAAATGCAT',
	'f49':'CAGTGGGTGTGAATGTTCTTATTTGT',
	'f50':'TATTGATTGGATATCACTTTTTCACATC',
	'f51':'CTTATTTTTCTTTGAAAAATGTTTTCAAG',
	'f52':'CAGCAAAACCCACCAGGCCTATTC',
	'f53':'CAAATCTTTTATCAGATAGATAATTGGC',
	'f54':'CATGTAGAGCAGTACCATAATTGTTAG',
	'f55':'TGAATGAAAATTACCCACTTCTCATTAG',
	'f56':'CACAAAGCTAACAAGAGTGGAGCC',
	'f57':'TACAAGGGCCTGAGCCAAAGTGG',
	'f58':'CCACCCTCTAATACCTAAGTGGAAA',
	'f59':'CTTTTAACTCTAAGAAAATGGCAGCTC',
	'f60':'TGTGTAAGGCCAATGCCTGGGAG',
	'f61':'CAAGTGGTAAAGGCCCTCACAGAG',
	'f62':'CTTCAGCGTCCAGGTCTCCCTC',
	'f63':'CACGGGAGCCCCGGGTAGTAAC',
	'f64':'TAATCCTATCTCTTGTCTCTGCTTCT',
	'f65':'CCCTTTTAAAATATACTTTTTTACACATG',
	'f66':'TGCAGCACTGGAAACCTCTGTAGT',
	'f67':'TAAAGAAAGCACTCTGAAGGCATGG',
	'f68':'TTTATGTGTGAATGTGTTAGAAAATTGTG',
	'f69':'CTTGATTTAGGAAATGAAGTTGTGCTA',
	'f70':'CATTGGTCATAACCAATGAACCAATAT',
	'f71':'TATTTTCTCTATCAGTACTTCAAAAATAAT',
	'f72':'CCCTCTTTGTGTTGTAGTCCATGC',
	'f73':'CCCAGACAGCACCTACAAGCAGG',
	'f74':'TCTCTGCTAGGGTTTCATGACTTCG',
	'f75':'TGTGGAATACAGAATAATTTGACTTTAAT'
}
tempo = {}
for i,seq in ext_primers.iteritems():
	try: tempo[seq[:19]].append(i)
	except KeyError: tempo[seq[:19]] = [i]
extbyseq = tempo
tempo = {}
for i,seq in tj_primers.iteritems():
	try: tempo[seq[-19:]].append(i)
	except KeyError: tempo[seq[-19:]] = [i]
tjbyseq = tempo
tempo={}
for i in range(19):
	tempo[i]={}
	for ID,seq in ext_primers.iteritems():
		try:tempo[i][seq[i]].append(ID)
		except KeyError:tempo[i][seq[i]]=[ID]
extprimerpositions=tempo
#####
#check if run or imported // call main() or not
#####
if __name__ == "__main__":
    main()
#END of script
