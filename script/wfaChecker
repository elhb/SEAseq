#! /usr/bin/env python

import sys

def main():
    import sys
    import multiprocessing

    results = Results()
    
    outfile = open(sys.argv[3],'w')
    
    #poolOfProcesses = multiprocessing.Pool(16,maxtasksperchild=100000000)
    #parallelResults = poolOfProcesses.imap_unordered(foreachRead,readPairGenerator(sys.argv[1],sys.argv[2]),chunksize=10000)
    #parallelResults = poolOfProcesses.imap(foreachRead,readPairGenerator(sys.argv[1],sys.argv[2]),chunksize=1000)
    
    #for readpair in parallelResults:
    inserts = []
    
    for readpair in readPairGenerator(sys.argv[1],sys.argv[2]):
        foreachRead(readpair)
        if readpair.id > 10000:break
        readpair.fixInsert()
        readpair.matchdbs()
        results.add(readpair)
        #inserts.append([readpair.id,readpair.insert])
        if readpair.insert and len(readpair.insert) >= 50:outfile.write( '>'+str(readpair.id)+'\n'+str(readpair.insert)+'\n') 
    outfile.close()
    #print inserts
    
    results.printsummary()

def foreachRead(readpair):
    readpair.identifyDirection()
    readpair.matchHandles()

class Results():
    
    def __init__(self, ):
        self.totalReads = 0
        self.directions = {}
        self.constructType = {}
        self.dbsmatches = {}
    
    def add(self, readpair):
        self.totalReads += 1
        try: self.directions[readpair.direction] += 1
        except KeyError: self.directions[readpair.direction] = 1
        try: self.constructType[readpair.construct] += 1
        except KeyError: self.constructType[readpair.construct] = 1
        try: self.dbsmatches[readpair.dbsmatch] += 1
        except KeyError: self.dbsmatches[readpair.dbsmatch] = 1

    def printsummary(self):
        print '\n##### SUMMARY #####'
        
        print self.totalReads
        
        print 'Directions:'
        for direction,count in self.directions.iteritems():
            print str(direction) +'\t'+str(percentage(count,self.totalReads))
        print ''
        
        print 'CunstructType:'
        for constructtype,count in self.constructType.iteritems():
            print str(constructtype) +'\t'+str(percentage(count,self.totalReads))
        print ''
        
        print 'DBSmatch:'
        for match,count in self.dbsmatches.iteritems():
            if match != None: print ' '+str(match) +'\t'+str(percentage(count,self.totalReads-self.dbsmatches[None]))+' (% of total-None)'
            else: print ' '+str(match) +'\t'+str(percentage(count,self.totalReads))+' (% of total)'
        print ''
    
def readPairGenerator(fastq1,fastq2):

    #
    # imports
    #
    import gzip
    import sys

    #
    # Loop through infiles
    #
    currentRead = 0
    totalReadcount = 0
    readcount = bufcount(fastq1)/4
    readfromdiskProgress = Progress(readcount, unit='reads-read-from-disk', mem=True)
    with readfromdiskProgress:
        #for filePairId, readcount, fastq1, fastq2 in self.infiles:
        sys.stderr.write(str(currentRead)+' read pairs read from infiles, now starting to read from '+fastq1+'.\n')
        totalReadcount += readcount
        
        #
        # Open the files
        #
        if fastq1.split('.')[-1] in ['gz','gzip']: file1 = gzip.open(fastq1)
        else: file1 = open(fastq1,'r')
        if fastq2.split('.')[-1] in ['gz','gzip']: file2 = gzip.open(fastq2)
        else: file2 = open(fastq2,'r')
        
        while 'NOT EOFError':
            try:
                header1 = file1.readline().rstrip()
                header2 = file2.readline().rstrip()
                sequence1 = file1.readline().rstrip()
                sequence2 = file2.readline().rstrip()
                trash = file1.readline().rstrip()
                trash = file2.readline().rstrip()
                qual1 = file1.readline().rstrip()
                qual2 = file2.readline().rstrip()
                if not header1: break
                currentRead += 1
                # data base has following info:
                #    (id,header,sequence1,sequence2,quality1,quality2,barcodeSequence,clusterId,annotation,fromFastq)
                barcodeSequence = None
                clusterId = None
                annotations = {}
                pair = ReadPair(currentRead, header1, header2, sequence1, sequence2, qual1, qual2,barcodeSequence,clusterId,annotations, 0)#fastq1)
                readfromdiskProgress.update()
                yield pair#self.currentRead, header1, header2, sequence1, sequence2, qual1, qual2, fastq1
            except EOFError: break
        assert totalReadcount == currentRead, 'Error while reading infiles: Read count after file '+fastq1+' is '+str(currentRead)+' should theoretically be '+str(totalReadcount)+'.\n'
        sys.stderr.write('Reached the end of '+fastq1+'.\n')
    grandTotal = totalReadcount
    sys.stderr.write(str(grandTotal)+' read pairs read from infiles.\n')
    #SEAseqPipeLine.results.setResult('totalReadCount',grandTotal)

def bufcount(filename):
	""" returns the number of lines in a file
	"""
	import gzip
	if filename.split('.')[-1] in ['gz','gzip']: f = gzip.open(filename)
	else: f = open(filename)
	lines = 0
	buf_size = 1024 * 1024
	read_f = f.read # loop optimization
	
	buf = read_f(buf_size)
	while buf:
		lines += buf.count('\n')
		buf = read_f(buf_size)
		f.close
	return lines

def hamming_distance(s1, s2):
	assert len(s1) == len(s2), 'Error: '+str(len(s1)) + ' != ' + str(len(s2))+' '+s1+' '+s2
	return sum(ch1 != ch2 for ch1, ch2 in zip(s1, s2))

def levenshtein(s1, s2):
	if len(s1) < len(s2):
		return levenshtein(s2, s1)
	if not s1:
		return len(s2)
	previous_row = xrange(len(s2) + 1)
	for i, c1 in enumerate(s1):
		current_row = [i + 1]
		for j, c2 in enumerate(s2):
			insertions = previous_row[j + 1] + 1 # j+1 instead of j since previous_row and current_row are one character longer
			deletions = current_row[j] + 1       # than s2
			substitutions = previous_row[j] + (c1 != c2)
			if c1 == 'N' or c2 == 'N': substitutions -= 1 #if N then no mismatch
			current_row.append(min(insertions, deletions, substitutions))
		previous_row = current_row
	return previous_row[-1]

class ReadPair(object):
    
    def __init__(self, currentRead, header1, header2, sequence1, sequence2, qual1, qual2,handleCoordinates,clusterId,annotations, fastq1):
	self.id = currentRead
	self.r1Header   = header1
	self.r2Header   = header2
	self.r1Seq      = strip3primN(sequence1)
	self.r2Seq      = strip3primN(sequence2)
	self.r1Qual     = qual1
	self.r2Qual     = qual2
	self.fileOrigin = fastq1
	self.handleCoordinates = handleCoordinates
	self.annotations= annotations    

        self.h770 = None
        self.h1691= None
        self.h4328= None
        self.dbsmatch = None
        self.overlap = None
        self.brokenSequence = ''
        self.construct = None
        self.insert= None
        self.dbs = None

    def fixInsert(self,):
        if self.insert:
            self.insert=self.insert.replace('.','')
            self.insert = self.insert.split('  ')
            if len(self.insert)>1:
                if len(self.insert[0])>len(self.insert[1]):
                    longInsertPart = self.insert[0]
                    shortInsertPart = self.insert[1]
                else:
                    longInsertPart = self.insert[1]
                    shortInsertPart = self.insert[0]
                    
                self.insert = longInsertPart
            else: self.insert = self.insert[0]

                #start,end,missmatches = self.matchSequence(longInsertPart,shortInsertPart,int(round(len(shortInsertPart)*0.1))+2)
                
                #print longInsertPart[:start] + '-'+longInsertPart[start:end] + '-' + longInsertPart[end:]
                
            #print self.insert

    def matchdbs(self,):

        if self.dbs:

            dbsSeq=self.dbs.replace('.','')
            dbsSeq = dbsSeq.split('  ')
            if len(dbsSeq)!=1:dbsSeq = ''
            else: dbsSeq = dbsSeq[0]

            dbs = 'BDHVBDHVBDHVBDHVBDHV'
            dbsRegex = UIPAC2REGEXP(dbs)
            import re
            
            if dbsSeq:
                match = re.match(dbsRegex,self.dbs)
                if match:
                    self.dbsmatch = True
                    #print 'woohooo!',dbsSeq
                else:
                    self.dbsmatch = False
                    #print 'ohhhnooooo!',dbsSeq
            else:pass#print 'BADSEQUENCE!',dbsSeq
            
    def matchSequence(self, readsequence, matchsequence, maxDistance, matchfunk=hamming_distance, startOfRead=False):
	
	import re
	#matchfunk = hamming_distance

	startPosition = None
	endPosition   = None
	missmatches   = None

	perfect_match = re.search(matchsequence, readsequence)
	if perfect_match:
	    startPosition = perfect_match.start()
	    endPosition = perfect_match.end()
	    missmatches = 0
	
	elif int(maxDistance):
	    mindist = [10000,-1]
            goto = len(readsequence)
            if startOfRead: goto = 30
	    for i in range(goto):
		
		if i+len(matchsequence) <= len(readsequence): dist = matchfunk(matchsequence,readsequence[i:i+len(matchsequence)])
		else: dist = 10001
		
		if dist < mindist[0]: mindist =[dist,i]

	    if mindist[0] < int(maxDistance)+1:
		startPosition = mindist[1]
		endPosition = mindist[1]+len(matchsequence)
		missmatches = mindist[0]
	    else:
		startPosition = None
		endPosition = None
		missmatches = None

	return [startPosition,endPosition,missmatches]
    
    def matchHandles(self,):
        print str(self.id)+''.join([' ' for i in range(10-len(str(self.id)))]),
        
        if   self.direction == '1 -> 2':
            print self.direction,
            if len(self.r2Seq) > len(self.r1Seq) and hamming_distance(self.r1Seq,revcomp(self.r2Seq)[:len(self.r1Seq)]) < 4:
                self.overlap = True
                self.brokenSequence = revcomp(self.r2Seq)

            else:
                self.brokenSequence = self.r1Seq+' '+'.'.join(['' for i in range(160-len(self.r2Seq)-len(self.r1Seq))])+' '+revcomp(self.r2Seq)

        elif self.direction == '2 -> 1':
            print self.direction,
            if len(self.r2Seq) > len(self.r1Seq) and hamming_distance(self.r2Seq[-len(self.r1Seq):],revcomp(self.r1Seq)) < 4:
                self.overlap = True
                self.brokenSequence = self.r2Seq
            else:
                self.brokenSequence = self.r2Seq+' '+'.'.join(['' for i in range(160-len(self.r2Seq)-len(self.r1Seq))])+' '+revcomp(self.r1Seq)

        else: print 'Direction not identifyable ', self.r1Seq+' '+'.'.join(['' for i in range(160-len(self.r2Seq)-len(self.r1Seq))])+' '+revcomp(self.r2Seq)
        
        if self.direction:
            
            outputSeq = self.brokenSequence

            h770start,h770end,missmatches = self.matchSequence(outputSeq,'GGAGCCATTAAGTCGTAGCT',4)
            if h770start != None:
                if h770start == 0: self.h770 = True
                else:self.h770 = False
                outputSeq = outputSeq[:h770start] + '-'+'\033[34m'+outputSeq[h770start:h770end] +'\033[0m'+ '-' + outputSeq[h770end:]
            
            
            h1691start,h1691end,missmatches = self.matchSequence(outputSeq,'CATGACCTCTTGGAACTGTC',4)
            if h1691start != None:
                self.h1691 = True
                if self.h1691 and self.h770: self.dbs = outputSeq[h770end+11:h1691start]
                outputSeq = outputSeq[:h1691start] + '-'+'\033[95m'+outputSeq[h1691start:h1691end]+'\033[0m' + '-' + outputSeq[h1691end:]
            
            
            h4328start,h4328end,missmatches = self.matchSequence(outputSeq,'ATACTGAGACGCTGGTCCTA',4)
            if h4328start != None:
                if  h4328end == len(outputSeq): self.h4328 = True
                else: self.h4328 = False
                if h1691start != None: self.insert = outputSeq[h1691end+11:h4328start]
                outputSeq = outputSeq[:h4328start] + '-'+'\033[93m'+outputSeq[h4328start:h4328end]+'\033[0m' + '-' + outputSeq[h4328end:]

            ##mark partials
            #h770startPart1,h770endPart1,missmatches = self.matchSequence(outputSeq,'GGAGCCATT',1)
            #if h770startPart1 != None: outputSeq = outputSeq[:h770startPart1] + ''+'\033[31m'+outputSeq[h770startPart1:h770endPart1]+'\033[0m' + '' + outputSeq[h770endPart1:]
            #h770startPart2,h770endPart2,missmatches = self.matchSequence(outputSeq,'GTCGTAGCT',1)
            #if h770startPart2 != None: outputSeq = outputSeq[:h770startPart2] + ''+'\033[31m'+outputSeq[h770startPart2:h770endPart2]+'\033[0m' + '' + outputSeq[h770endPart2:]
            #
            #h1691startPart1,h1691endPart1,missmatches = self.matchSequence(outputSeq,'CATGACCTC',1)
            #if h1691startPart1 != None: outputSeq = outputSeq[:h1691startPart1] + ''+'\033[31m'+outputSeq[h1691startPart1:h1691endPart1]+'\033[0m' + '' + outputSeq[h1691endPart1:]
            #h1691startPart2,h1691endPart2,missmatches = self.matchSequence(outputSeq,'GGAACTGTC',1)
            #if h1691startPart2 != None: outputSeq = outputSeq[:h1691startPart2] + ''+'\033[31m'+outputSeq[h1691startPart2:h1691endPart2]+'\033[0m' + '' + outputSeq[h1691endPart2:]
            #
            #h4328startPart1,h4328endPart1,missmatches = self.matchSequence(outputSeq,'ATACTGAGA',1)
            #if h4328startPart1 != None: outputSeq = outputSeq[:h4328startPart1] + ''+'\033[31m'+outputSeq[h4328startPart1:h4328endPart1]+'\033[0m' + '' + outputSeq[h4328endPart1:]
            #h4328startPart2,h4328endPart2,missmatches = self.matchSequence(outputSeq,'CTGGTCCTA',1)
            #if h4328startPart2 != None: outputSeq = outputSeq[:h4328startPart2] + ''+'\033[31m'+outputSeq[h4328startPart2:h4328endPart2]+'\033[0m' + '' + outputSeq[h4328endPart2:]

            if self.overlap: print 'OLP', outputSeq,
            else:print '   ', outputSeq,
            
            if self.h770 and self.h1691 and self.h4328:
                self.construct = 'constructOK'
            else: 
                self.construct =''
                if not self.h770: self.construct += ' h770 '
                if not self.h4328: self.construct += ' h4328 '
                if not self.h1691: self.construct += ' h1691'
                if self.h770 and self.h4328 and not self.h1691: self.construct = ' h1691-SemiOK'
            print self.construct

    def identifyDirection(self,):
        
        self.direction = None
        
        startPosition,endPosition,missmatches = self.matchSequence(self.r1Seq,'GGAGCCATTAAGTCGTAGCT',4)
        
        if startPosition!=None:
            self.direction = '1 -> 2'
            #print self.r1Seq[:startPosition]+'-'+self.r1Seq[startPosition:endPosition]+'-'+self.r1Seq[endPosition:]+'-'+str(missmatches),
        else:
            #startPosition,endPosition,missmatches = self.matchSequence(self.r1Seq,'GGAGCCATTAAGTCGTAGCT',4,matchfunk=levenshtein)
            #print '-'+self.r1Seq[:30],startPosition,'testing other direction',
            startPosition,endPosition,missmatches = self.matchSequence(self.r1Seq,'TAGGACCAGCGTCTCAGTAT',4)
            if startPosition!=None:
                self.direction = '2 -> 1'
                #print self.r1Seq[:startPosition]+'-'+self.r1Seq[startPosition:endPosition]+'-'+self.r1Seq[endPosition:]+'-'+str(missmatches),
            else: pass#print '-'+self.r1Seq[:30], startPosition,
        #print self.direction

        startPosition,endPosition,missmatches = self.matchSequence(self.r2Seq,'GGAGCCATTAAGTCGTAGCT',4)
        if startPosition!=None:
            self.direction = '2 -> 1'
        else:
            startPosition,endPosition,missmatches = self.matchSequence(self.r2Seq,'TAGGACCAGCGTCTCAGTAT',4)
            if startPosition!=None:
                self.direction = '1 -> 2'
            else: pass
    
  
    def isIlluminaAdapter(self, ):
	
	import math
	
	for i in [15]:#range(15):
	    handleStartPosition,handleEndPosition,handleMissMatches = self.matchSequence(self.r1Seq, 'AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC'[:35-i], int(math.ceil(float(35-i)*0.1)))
	    if handleStartPosition:
		self.annotations['Read1IsIlluminaAdapter'] = str(handleMissMatches)+':'+ str(handleStartPosition)
		break
	
	for i in [15]:#range(15):
	    handleStartPosition,handleEndPosition,handleMissMatches = self.matchSequence(self.r2Seq, 'AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT'[:34-i], int(math.ceil(float(34-i)*0.1)))
	    if handleStartPosition:
		self.annotations['Read2IsIlluminaAdapter'] = str(handleMissMatches)+':'+ str(handleStartPosition)
		break

    def identifyBarcode(self, ):

	handleStartPosition,handleEndPosition,handleMissMatches = self.matchSequence(self.r1Seq, SEAseqPipeLine.settings.handleSequence, SEAseqPipeLine.settings.maxHandleMissMatches)
	
	if handleMissMatches > 0 or handleMissMatches == None: self.annotations['handleMissMatches'] = handleMissMatches
	elif handleMissMatches == 0:self.annotations['handlePerfectMatch'] = True
	else: raise ValueError, 'handleMissMatches must be integer >= 0 or None'
	
	if handleStartPosition == SEAseqPipeLine.settings.barcodeLength:
	    self.handleCoordinates = [handleStartPosition,handleEndPosition]
	elif handleStartPosition == None: self.annotations['handleNotFound'] = True
	else: self.annotations['ErronousHandlePosition'] = handleStartPosition

class Progress():

	def __init__(self,total, verb='full', logfile=sys.stderr, unit='reads' ,mem=False, printint=0):
		import time
		self.total = total
		self.current = 0
		self.type = verb
		self.logfile = logfile
		self.ltime = time.time()
		self.lcurrent = self.current
		self.lpercentage = 0
		if verb == 'full': self.printint = 5
		elif verb == 'minimal':self.printint = 5
		self.unit = unit
		self.mem = mem
		if printint: self.printint = printint

	def __enter__(self):
		if self.type == 'minimal': self.logfile.write('0%                 50%                 100%\n')
		#                                              ....................................................................................

	def update(self):
		import time
		self.current += 1
		self.percentage = int(round(100*float(self.current)/self.total))
		if self.percentage % self.printint == 0 and self.percentage != self.lpercentage:
			self.stf=int(round((self.total-self.current)/((self.current-self.lcurrent)/(time.time()-self.ltime))))
			if self.type == 'full': self.logfile.write(
				'#Progress => '+str(self.percentage)+'%, '+
				str( round((self.current-self.lcurrent)/(time.time()-self.ltime),2) )+' '+self.unit+'/second, '+
				time.strftime("%A, %d %b %Y %H:%M:%S",time.localtime())+
				', left: '+str(self.stf/60/60)+'h '+str(self.stf/60%60)+'min '+str(self.stf%60)+'s')
			if self.mem:
				import resource
				self.logfile.write(', using '+str((resource.getrusage(resource.RUSAGE_SELF).ru_maxrss+resource.getrusage(resource.RUSAGE_CHILDREN).ru_maxrss)/1024)+' ('+str(resource.getrusage(resource.RUSAGE_SELF).ru_maxrss/1024)+') MB.\n')
			else:	self.logfile.write('\n')
			if self.type == 'minimal': self.logfile.write('..')
			self.ltime = time.time()
			self.lcurrent = self.current
			self.lpercentage = self.percentage

	def __exit__(self, *args):
		self.logfile.write('\n')

def revcomp(string):
	''' Takes a sequence and reversecomplements it'''
	complementary = comp(string)
	return complementary[::-1]

def comp(string):
	''' Takes a sequence and complements it'''
	complement = {'A':'T','T':'A',
				  'C':'G','G':'C',
				  'N':'N',
				  'R':'Y','Y':'R',
				  'K':'M','M':'K',
				  'B':'V','V':'B',
				  'D':'H','H':'D',
				  }
	compseq = "".join([complement.get(nt.upper(), '') for nt in string])
	return compseq

def strip3primN(string):
    
    while string and string[-1] == 'N': string = string[:-1]
    
    return string

def percentage(count,total):
    if str in [type(count),type(total)]: return 'NA'
    if 'NA' in [total,count]: return 'NA'
    if float(total) <=0.0: return 'NA'
    #return round(float(count) / float(total),4)
    return round(100* float(count) / float(total),2)

def uipac(bases, back='uipac'): #U	Uracil NOT SUPPORTED!!!
	if back == 'uipac':
		if 'N' in bases: return 'N'
		uniqbases={}
		for i in bases:
			uniqbases[i]=True
		bases = uniqbases.keys()
		if 'U' in bases: sys.stderr.write('WARNING in function "uipac(bases)": Uracil NOT SUPPORTED!')
		if len(bases)==1:
			if 'A' in bases: return 'A' #A	Adenine
			if 'C' in bases: return 'C' #C	Cytosine
			if 'G' in bases: return 'G' #G	Guanine
			if 'T' in bases: return 'T' #T	Thymine
			#U	Uracil NOT SUPPORTED!!!
		if len(bases)==2:
			if 'A' in bases and 'G' in bases: return 'R' #R	Purine (A or G)
			if 'C' in bases and 'T' in bases: return 'Y' #Y	Pyrimidine (C, T, or U)
			if 'A' in bases and 'C' in bases: return 'M' #M	C or A
			if 'T' in bases and 'G' in bases: return 'K' #K	T, U, or G
			if 'A' in bases and 'T' in bases: return 'W' #W	T, U, or A
			if 'C' in bases and 'G' in bases: return 'S' #S	C or G
		if len(bases)==3:
			if 'C' in bases and 'T' in bases and 'G' in bases: return 'B' #B	C, T, U, or G (not A)
			if 'A' in bases and 'T' in bases and 'G' in bases: return 'D' #D	A, T, U, or G (not C)
			if 'A' in bases and 'T' in bases and 'C' in bases: return 'H' #H	A, T, U, or C (not G)
			if 'A' in bases and 'C' in bases and 'G' in bases: return 'V' #V	A, C, or G (not T, not U)
		if len(bases)==4:
			return 'N' #N	Any base (A, C, G, T, or U)
	elif back == 'bases':
		if   bases == 'R': return ['A','G'] 
		elif bases == 'Y': return ['C','T']
		elif bases == 'M': return ['A','C']
		elif bases == 'K': return ['G','T']
		elif bases == 'W': return ['A','T']
		elif bases == 'S': return ['C','G']
		elif bases == 'B': return ['C','T','G']
		elif bases == 'D': return ['A','T','G']
		elif bases == 'V': return ['A','C','G']
		elif bases == 'H': return ['A','C','T']
		elif bases == 'N': return ['A','G','T','C']

def UIPAC2REGEXP(string):
    return string.replace('R','[AG]').replace('Y','[CT]').replace('S','[GC]').replace('W','[AT]').replace('K','[GT]').replace('M','[AC]').replace('B','[CGT]').replace('D','[AGT]').replace('H','[ACT]').replace('V','[ACG]').replace('N','[AGTC]')

if __name__ == "__main__": main()